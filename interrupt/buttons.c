/*----------------------------------------------------------------------------
 *      
 *----------------------------------------------------------------------------
 *      Name:    BUTTONS.H
 *      Purpose: Microprocessors Laboratory
 *----------------------------------------------------------------------------
 *      
 *      Author: Pawel Russek AGH University of Science and Technology
 *---------------------------------------------------------------------------*/

#include "MKL46Z4.h"                    /* Device header */
#include "buttons.h"
#include "leds.h"

#define SW1_PIN 3												/* SW1 switch is on port C - pin 3 */
#define SW3_PIN 12

/*Number of IRQ generated by PORTC_PORTD interrupt*/
#define PORTC_D_IRQ_NBR (IRQn_Type) PORTC_PORTD_IRQn					/* ToDo 5.1: Define interrupt (IRQ) number for PORTC_PORTD. See interrupt vector assignments in NVIC section of KL46 Sub-Family Reference Manual - NVIC section*/ 

uint8_t change_change;
/*----------------------------------------------------------------------------
	Interrupt service routine
	Button will cause PORTC_PORTD interrupt 
 *----------------------------------------------------------------------------*/
void PORTC_PORTD_IRQHandler(void){		/* ToDo 5.2: Put a proper name of PORTC_PORTD Interrupt service routine ISR. See system_MKL46Z4.s file for function name */ 
if(buttonRead()== 1){	
	buttonsService();
}
if(buttonRead3() == 1){
	buttonsService3();
}
	while((FPTC->PDIR&(1<<SW1_PIN))==0);				/* ToDo 7.1: Enable wait in the interrupt for SW1 button release */
	while((FPTC->PDIR&(1<<SW3_PIN))==0);

	PORTC->PCR[SW1_PIN] |= PORT_PCR_ISF_MASK;
	PORTC->PCR[SW3_PIN] |= PORT_PCR_ISF_MASK;	/* ToDo 5.3: Clear interrupt service flag in port control register otherwise int. remains active */
}

/*----------------------------------------------------------------------------
	Function initializes port C pin for switch 1 (SW1) handling
	and enables PORT_C_D interrupts
 *----------------------------------------------------------------------------*/
void buttonsInitialize(void){
	
	SIM->SCGC5 |=  SIM_SCGC5_PORTC_MASK; 					/* Enable clock for port C */
	PORTC->PCR[SW1_PIN] |= PORT_PCR_MUX(1);
	PORTC->PCR[SW3_PIN] |= PORT_PCR_MUX(1);	/* Pin PTC3 is GPIO */
	
	/* Port control register for bit 3 of port C configuration. Activate pull up and interrupt */
		PORTC->PCR[SW1_PIN] |=  PORT_PCR_PS_MASK |		/* ToDo 5.4: Set bit in PCR register to enable pull resistor. See KL46 Sub-Family Reference Manual */
														PORT_PCR_PE_MASK;		/* ToDo 5.5: Set bit in PCR register to select pull up. See KL46 Sub-Family Reference Manual */
		PORTC->PCR[SW1_PIN] |= 	PORT_PCR_IRQC(10);		/* ToDo 5.6: Set value for IRQC bit field in PCR register to select falling edge interrupts for PORTC[3]. See KL46 Sub-Family Reference Manual */
		
		PORTC->PCR[SW3_PIN] |=  PORT_PCR_PS_MASK |
														PORT_PCR_PE_MASK;	
		PORTC->PCR[SW3_PIN] |= 	PORT_PCR_IRQC(10);
	
	/*ARM's Nested Vector Interrupt Controller configuration*/
	NVIC_ClearPendingIRQ(PORTC_D_IRQ_NBR);				/* Clear NVIC any pending interrupts on PORTC_D */
	NVIC_EnableIRQ(PORTC_D_IRQ_NBR);							/* Enable NVIC interrupts source for PORTC_D module */
	
	NVIC_SetPriority (PORTC_D_IRQ_NBR, 3);			/* ToDo 7.2a: Set PORTC_D interrupt priority level  */ 

}

/*----------------------------------------------------------------------------
	Function reads SW 1 state
*----------------------------------------------------------------------------*/
int32_t buttonRead(){
	return FPTC->PDIR & (1UL<<SW1_PIN);// || FPTC->PDIR & (1UL<<SW3_PIN);						/* Get port data input register (PDIR) */
}	
int32_t buttonRead3(){
	return FPTC->PDIR & (1UL<<SW3_PIN);
}
	/*----------------------------------------------------------------------------
	Function services PORT_C_D interrupt
*----------------------------------------------------------------------------*/

void buttonsService(void){
	fastSlowFSM();																/* Toggle leds FSM spee mode */ 
}

void buttonsService3(void){
	change1();
	//fastSlowFSM();
}
